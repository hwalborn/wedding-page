{"ast":null,"code":"import api from '../data/apiKey';\nexport default {\n  googleSheets: function googleSheets(sheet, stateCallback) {\n    // lets do this async, build a new promise\n    return new Promise(function (resolve, reject) {\n      // use the api key and the sheet passed in\n      fetch(\"https://sheets.googleapis.com/v4/spreadsheets/14OsbtSgGtA911j16Y_QjX6P_etYEJ4sahge0iQn8mcw/values:batchGet?key=\".concat(api.apiKey, \"&ranges=\").concat(sheet, \"&majorDimension=ROWS\")).then(function (resp) {\n        // make some json, this also happens async\n        resp.json().then(function (data) {\n          // build our object to return\n          var valueObjects = {}; // for the most part, we'll be building the same state every time.\n          // however for google maps, we should pass in a unique stateCallback\n          // because each google sheet row has text, long, lat, and description\n\n          if (stateCallback === undefined || stateCallback === null) {\n            data.valueRanges[0].values.forEach(function (value) {\n              valueObjects[value[0]] = [value[1], value[2]];\n            });\n          } else {\n            valueObjects = stateCallback(data);\n          } // resolve with some awesome data from google sheets\n\n\n          resolve(valueObjects);\n        });\n      });\n    });\n  }\n};","map":{"version":3,"sources":["/Users/Holt/Documents/real-pro/wedding-page/src/data/dataAccess.js"],"names":["api","googleSheets","sheet","stateCallback","Promise","resolve","reject","fetch","apiKey","then","resp","json","data","valueObjects","undefined","valueRanges","values","forEach","value"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,gBAAhB;AAEA,eAAe;AACbC,EAAAA,YAAY,EAAE,sBAACC,KAAD,EAAQC,aAAR,EAA0B;AACtC;AACA,WAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC;AACAC,MAAAA,KAAK,0HAAmHP,GAAG,CAACQ,MAAvH,qBAAwIN,KAAxI,0BAAL,CACCO,IADD,CACM,UAACC,IAAD,EAAU;AACd;AACAA,QAAAA,IAAI,CAACC,IAAL,GACCF,IADD,CACM,UAACG,IAAD,EAAU;AACd;AACA,cAAIC,YAAY,GAAG,EAAnB,CAFc,CAGd;AACA;AACA;;AACA,cAAGV,aAAa,KAAKW,SAAlB,IAA+BX,aAAa,KAAK,IAApD,EAAyD;AACvDS,YAAAA,IAAI,CAACG,WAAL,CAAiB,CAAjB,EAAoBC,MAApB,CAA2BC,OAA3B,CAAmC,UAACC,KAAD,EAAW;AAC5CL,cAAAA,YAAY,CAACK,KAAK,CAAC,CAAD,CAAN,CAAZ,GAAyB,CAACA,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,CAAzB;AACD,aAFD;AAGD,WAJD,MAIO;AACLL,YAAAA,YAAY,GAAGV,aAAa,CAACS,IAAD,CAA5B;AACD,WAZa,CAad;;;AACAP,UAAAA,OAAO,CAACQ,YAAD,CAAP;AACD,SAhBD;AAiBD,OApBD;AAqBD,KAvBM,CAAP;AAwBD;AA3BY,CAAf","sourcesContent":["import api from '../data/apiKey'\n\nexport default {\n  googleSheets: (sheet, stateCallback) => {\n    // lets do this async, build a new promise\n    return new Promise((resolve, reject) => {\n      // use the api key and the sheet passed in\n      fetch(`https://sheets.googleapis.com/v4/spreadsheets/14OsbtSgGtA911j16Y_QjX6P_etYEJ4sahge0iQn8mcw/values:batchGet?key=${api.apiKey}&ranges=${sheet}&majorDimension=ROWS`)\n      .then((resp) => {\n        // make some json, this also happens async\n        resp.json()\n        .then((data) => {\n          // build our object to return\n          var valueObjects = {}\n          // for the most part, we'll be building the same state every time.\n          // however for google maps, we should pass in a unique stateCallback\n          // because each google sheet row has text, long, lat, and description\n          if(stateCallback === undefined || stateCallback === null){\n            data.valueRanges[0].values.forEach((value) => {\n              valueObjects[value[0]] = [value[1], value[2]]\n            })\n          } else {\n            valueObjects = stateCallback(data)\n          }\n          // resolve with some awesome data from google sheets\n          resolve(valueObjects)\n        })\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}